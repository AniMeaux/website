import { watch } from "chokidar";
import { parse } from "node-html-parser";
import { mkdir, readFile, readdir, writeFile } from "node:fs/promises";
import { basename, dirname, join, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { oneAtTheTime, relativeToCwd, safelyReadFile } from "./shared";

const FILENAME = fileURLToPath(import.meta.url);
const DIRNAME = dirname(FILENAME);
const SCRIPT_NAME = relativeToCwd(FILENAME);
const SHAPE_SRC_DIRECTORY = resolve(DIRNAME, "../image-shapes");
const DEST_DIRECTORY = resolve(DIRNAME, "../src/generated");
const SPRITE_DEST_FILE = join(DEST_DIRECTORY, "image-shapes-sprite.svg");
const TYPES_DEST_FILE = join(DEST_DIRECTORY, "image-shape-id.ts");

const ARGS = {
  shouldMinify: process.argv.some((arg) => arg === "--minify"),
  shouldWatch: process.argv.some((arg) => arg === "--watch"),
};

// Ensure the destination directory exists.
await mkdir(DEST_DIRECTORY, { recursive: true });

try {
  await buildShapes();
} catch (error) {
  if (!ARGS.shouldWatch) {
    throw error;
  }

  console.error(error);
}

if (ARGS.shouldWatch) {
  // In watch mode we don't want to have parallel builds.
  const safelyBuildIcons = oneAtTheTime(async () => {
    try {
      await buildShapes();
    } catch (error) {
      console.error(error);
    }
  });

  const watcher = watch([SHAPE_SRC_DIRECTORY], {
    // We already built once.
    ignoreInitial: true,

    // To avoid building to fast.
    awaitWriteFinish: {
      stabilityThreshold: 100,
      pollInterval: 100,
    },
  })
    .on("error", console.error)
    .on("all", safelyBuildIcons);

  process.once("SIGINT", async () => {
    try {
      await watcher.close();
    } catch (error) {
      console.error("Could not stop watcher:", error);
    }

    process.exit(0);
  });

  console.log("Watching for changes. Press Ctrl-C to stop.");
}

async function buildShapes() {
  console.log("Building...");

  const shapes = await getAllShapes();

  await Promise.all([
    generateShapeTypesFile(shapes),
    generateSpriteFile(shapes),
  ]);
}

type ShapeDescriptor = {
  /**
   * Absolute pathname of the SVG file.
   */
  pathname: string;

  /**
   * Unique identifier of an shape.
   */
  id: string;
};

/**
 * Get all SVG shape from the _imageShapes/_ folder.
 *
 * @returns Shape descriptors.
 */
async function getAllShapes() {
  const filenames = await readdir(SHAPE_SRC_DIRECTORY);

  // Sort alphabetically to ease search in generated files.
  filenames.sort();

  return filenames.map<ShapeDescriptor>((filename) => ({
    id: basename(filename, ".svg"),
    pathname: join(SHAPE_SRC_DIRECTORY, filename),
  }));
}

/**
 * Generates the types file.
 * The `IconName` type contains all possible names.
 *
 * @param shapes All icon descriptors.
 */
async function generateShapeTypesFile(shapes: ShapeDescriptor[]) {
  const content = `// This file is generated by ${SCRIPT_NAME}
export type ImageShapeId = 
${shapes.map((icon) => `  | "${icon.id}"`).join("\n")};
`;

  const currentContent = await safelyReadFile(TYPES_DEST_FILE);
  if (currentContent === content) {
    console.info(`Type file didn't change (${relativeToCwd(TYPES_DEST_FILE)})`);

    // The types will not change so we don't re-generate it to avoid triggering
    // a re-build of remix.
    return;
  }

  await writeFile(TYPES_DEST_FILE, content);
  console.info(`Built types (${relativeToCwd(TYPES_DEST_FILE)})`);
}

/**
 * Generates the SVG sprite file.
 *
 * @param shape All shape descriptors.
 */
async function generateSpriteFile(shape: ShapeDescriptor[]) {
  const contents = await Promise.all(shape.map(generateSymbolForShape));

  let sprite = [
    '<?xml version="1.0" encoding="UTF-8"?>',
    ARGS.shouldMinify
      ? undefined
      : `<!-- This file is generated by ${SCRIPT_NAME} -->`,
    '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">',
    // Don't wrap `symbol` elements in a `defs` as browser handle them
    // differently.
    // https://stackoverflow.com/a/74173265
    contents.map((content) => `  ${content}`).join("\n"),
    "</svg>",
  ]
    .filter(Boolean)
    .join("\n");

  if (ARGS.shouldMinify) {
    sprite = sprite.replace(/\n\s*/g, "");
  }

  const currentSprite = await safelyReadFile(SPRITE_DEST_FILE);
  if (currentSprite === sprite) {
    console.info(
      `SVG sprite didn't change (${relativeToCwd(SPRITE_DEST_FILE)})`,
    );

    // The SVG sprite will not change so we don't re-generate it to avoid
    // triggering a re-build of remix.
    return;
  }

  await writeFile(SPRITE_DEST_FILE, sprite);
  console.info(`Built SVG sprite (${relativeToCwd(SPRITE_DEST_FILE)})`);
}

async function generateSymbolForShape(shape: ShapeDescriptor) {
  const root = parse(await readFile(shape.pathname, "utf-8"));

  const svg = root.querySelector("svg");
  if (svg == null) {
    throw new Error(`No SVG element found in ${shape.pathname}.`);
  }

  // Make it a valid SVG symbol.
  // https://developer.mozilla.org/en-US/docs/Web/SVG/Element/symbol
  svg.tagName = "symbol";
  svg.removeAttribute("viewBox");
  svg.removeAttribute("xmlns");
  svg.removeAttribute("xmlns:xlink");

  const path = svg.querySelector("path");
  if (path == null) {
    throw new Error(`No path element found in ${shape.pathname}.`);
  }

  // The ID must be on the path to be used as clip path.
  path.setAttribute("id", shape.id);

  return svg.toString();
}
